name: Shared Build

permissions:
  contents: read
  id-token: write

on:
  workflow_call:
    inputs:
      store-artifacts:
        description: 'Flag if artifacts should be stored'
        type: boolean
        required: true
        default: false
      sign-binaries:
        description: 'Flag whether to sign the binaries'
        type: boolean
        required: false
        default: false
      configuration:
        description: 'The Visual Studio Configuration to build'
        type: string
        required: false
        default: 'Release'
    secrets:
      AZURE_CLIENT_ID:
        description: 'The Azure Client ID for authentication'
        required: false
      AZURE_TENANT_ID:
        description: 'The Azure Tenant ID for authentication'
        required: false
      AZURE_SUBSCRIPTION_ID:
        description: 'The Azure Subscription ID for authentication'
        required: false
      AZURE_KEYVAULT_URL:
        description: 'The Azure Key Vault URL for authentication'
        required: false
      AZURE_KEYVAULT_CERT_NAME:
        description: 'The Azure Key Vault Certificate Name for authentication'
        required: false

jobs:
  shared_build:
    name: Build Tools
    runs-on: windows-2025

    env:
      CertToolsPath: ${{ github.workspace }}\src\CertTools
      CertToolsSolutionPath: ${{ github.workspace }}\src\CertTools\CertTools.slnx
      AzureCertToolsPath: ${{ github.workspace }}\src\AzureCertTools
      AzureCertToolsSolutionPath: ${{ github.workspace }}\src\AzureCertTools\AzureCertTools.slnx
      BinaryOutputPath: ${{ github.workspace }}\bin

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Setup .NET SDK
    - name: Set up .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '10.x' # Use the latest .NET 10 SDK

    # Install AzureSignTool from NuGet
    - name: 'Setup: Install AzureSignTool'
      if:  ${{ inputs.store-artifacts && inputs.sign-binaries }}
      run: |
        dotnet tool install --global AzureSignTool
        dotnet tool install --global --prerelease sign
      shell: pwsh

    # Build Solution: determine and apply the version for the assemblies
    - name: 'Build: Determine Version'
      id: git-version
      uses: ./eng/actions/git-version

    - name: 'Build: Apply Version DEV'
      if: ${{ github.ref_type == 'branch' && github.ref != 'refs/heads/main' }}
      run: |
        echo "BUILD_VERSIONPREFIX=${{ steps.git-version.outputs.versionPrefix }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_VERSIONSUFFIX=${{ steps.git-version.outputs.versionSuffix }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_VERSIONREVISION=${{ steps.git-version.outputs.versionRevision }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_ASSEMBLYVERSION=${{ steps.git-version.outputs.assemblyVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_FILEVERSION=${{ steps.git-version.outputs.fileVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_PRODUCTVERSION=${{ steps.git-version.outputs.productVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_INFORMATIONALVERSION=${{ steps.git-version.outputs.informationalVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
      shell: pwsh

    - name: 'Build: Apply Version PROD'
      if: ${{ (github.ref_type == 'branch' && github.ref == 'refs/heads/main') || github.ref_type == 'tag' }}
      run: |
        echo "BUILD_VERSIONPREFIX=${{ steps.git-version.outputs.versionPrefix }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_VERSIONSUFFIX=${{ steps.git-version.outputs.versionSuffix }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_VERSIONREVISION=${{ steps.git-version.outputs.versionRevision }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_ASSEMBLYVERSION=${{ steps.git-version.outputs.assemblyVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_FILEVERSION=${{ steps.git-version.outputs.fileVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_PRODUCTVERSION=${{ steps.git-version.outputs.productVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        echo "BUILD_INFORMATIONALVERSION=${{ steps.git-version.outputs.informationalVersion }}" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
      shell: pwsh

    - name: 'Build: Restore CertTools'
      run: dotnet restore ${{ env.CertToolsSolutionPath }}
      shell: pwsh

    - name: 'Build: Build CertTools'
      run: dotnet build ${{ env.CertToolsSolutionPath }} --configuration ${{ inputs.configuration }} --no-restore
      shell: pwsh

    - name: 'Build: Publish CertTools/CreateRootCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.CertToolsPath }}\CreateRootCert\CreateRootCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh

    - name: 'Build: Publish CertTools/CreateSigningCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.CertToolsPath }}\CreateSigningCert\CreateSigningCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh

    - name: 'Build: Restore AzureCertTools'
      run: dotnet restore ${{ env.AzureCertToolsSolutionPath }}
      shell: pwsh

    - name: 'Build: Build AzureCertTools'
      run: dotnet build ${{ env.AzureCertToolsSolutionPath }} --configuration ${{ inputs.configuration }} --no-restore
      shell: pwsh

    - name: 'Build: Publish AzureCertTools/AzureCreateRootCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureCreateRootCert/AzureCreateRootCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh

    - name: 'Build: Publish AzureCertTools/AzureCreateIntermediateCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureCreateRootCert/AzureCreateRootCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh

    - name: 'Build: Publish AzureCertTools/AzureCreateSigningCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureCreateSigningCert/AzureCreateSigningCert.csproj --configuration ${{ inputs.configuration }} -p:PublishProfile=FolderProfile
        dotnet pack ${{ env.AzureCertToolsPath }}/AzureCreateSigningCert/AzureCreateSigningCert.csproj --configuration ${{ inputs.configuration }}
      shell: pwsh

    - name: 'Build: Publish AzureCertTools/AzureCreateSslServerCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureCreateSslServerCert/AzureCreateSslServerCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh

    - name: 'Build: Publish AzureCertTools/AzureDeleteCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureDeleteCert/AzureDeleteCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh
    
    - name: 'Build: Publish AzureCertTools/AzureDeleteCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureDeleteCert/AzureDeleteCert.csproj --configuration ${{ inputs.configuration }} --no-restore -p:PublishProfile=FolderProfile
      shell: pwsh

      # Login to Azure using a ServicePrincipal configured to authenticate agaist a GitHub Action
    - name: 'Az CLI login'
      if: ${{ inputs.store-artifacts && inputs.sign-binaries }}
      uses: azure/login@v1
      with:
        allow-no-subscriptions: true
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}

    - name: 'Build: Sign published binaries'
      shell: pwsh
      run: >
        ./sign code azure-key-vault
        **/*.exe
        --base-directory ${{ env.BinaryOutputPath }}
        --azure-credential-type "azure-cli"
        --azure-key-vault-url "${{ secrets.AZURE_KEYVAULT_URL }}"
        --azure-key-vault-certificate "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}"
        --timestamp-url "${{ secrets.AZURE_TIMESTAMP_URL }}"

    - name: 'Build: Sign published binaries'
      shell: pwsh
      run: >
        ./sign code azure-key-vault
        **/*.nupkg
        --base-directory ${{ env.BinaryOutputPath }}
        --azure-credential-type "azure-cli"
        --azure-key-vault-url "${{ secrets.AZURE_KEYVAULT_URL }}"
        --azure-key-vault-certificate "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}"
        --timestamp-url "${{ secrets.AZURE_TIMESTAMP_URL }}"

    - name: 'Build: signing cleanup'
      if:  ${{ inputs.store-artifacts && inputs.sign-binaries }}
      run: |
        Remove-Item -Path ${{ runner.temp }}\cert.pfx -ErrorAction Continue
      shell: pwsh

    - name: 'Store Artifacts: Binaries'
      uses: actions/upload-artifact@v4
      if: ${{ inputs.store-artifacts }}
      with:
        name: binaries
        path: ${{ env.BinaryOutputPath }}
