name: Shared Build

on:
  workflow_call:
    inputs:
      store-artifacts:
        description: 'Flag if artifacts should be stored'
        type: boolean
        required: true
        default: false
      sign-binaries:
        description: 'Flag whether to sign the binaries'
        type: boolean
        required: false
        default: false
      configuration:
        description: 'The Visual Studio Configuration to build'
        type: string
        required: false
        default: 'Release'
    secrets:
      SIGNING_CERT_PFX: 
        description: The Base64 encoded PFX file
        required: false
      SIGNING_CERT_PASSWORD: 
        description: The password for the PFX file
        required: false
      SIGNING_CERT_THUMBPRINT:
        description: The cert footprint
        required: false

jobs:
  shared_build:
    name: Build Tools
    runs-on: windows-2022

    env:
      CertToolsPath: ${{ github.workspace }}\src\CertTools
      CertToolsSolutionPath: ${{ github.workspace }}\src\CertTools\CertTools.sln
      AzureCertToolsPath: ${{ github.workspace }}\src\AzureCertTools
      AzureCertToolsSolutionPath: ${{ github.workspace }}\src\AzureCertTools\AzureCertTools.sln
      BinaryOutputPath: ${{ github.workspace }}\bin

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Setup .NET SDK
    - name: Set up .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.x' # Use the latest .NET 8 SDK

    # Build Solution: determine and apply the version for the assemblies
    - name: 'Build: Determine Version'
      id: git-version
      uses: ./eng/actions/git-version

    - name: 'Build: Apply Version DEV'
      if: ${{ github.ref_type == 'branch' && github.ref != 'refs/heads/main' }}
      run: |
        $versionPrefix = '${{ steps.git-version.outputs.versionPrefix }}'
        $versionSuffix = '${{ steps.git-version.outputs.versionSuffix }}'
        $versionRevision = '${{ steps.git-version.outputs.versionRevision }}'
        $assemblyVersion = '${{ steps.git-version.outputs.assemblyVersion }}'
        $fileVersion = '${{ steps.git-version.outputs.fileVersion }}'
        $productVersion = '${{ steps.git-version.outputs.productVersion }}'
        $informationalVersion = '${{ steps.git-version.outputs.informationalVersion }}'

        Write-Host "##vso[task.setvariable variable=Build.VersionPrefix]$versionPrefix"
        Write-Host "##vso[task.setvariable variable=Build.VersionSuffix]$versionSuffix"
        Write-Host "##vso[task.setvariable variable=Build.AssemblyVersion]$assemblyVersion"
        Write-Host "##vso[task.setvariable variable=Build.FileVersion]$fileVersion"
        Write-Host "##vso[task.setvariable variable=Build.ProductVersion]$productVersion"
        Write-Host "##vso[task.setvariable variable=Build.InformationalVersion]$informationalVersion"
      shell: pwsh

    - name: 'Build: Apply Version PROD'
      if: ${{ (github.ref_type == 'branch' && github.ref == 'refs/heads/main') || github.ref_type == 'tag' }}
      run: |
        $versionPrefix = '${{ steps.git-version.outputs.versionPrefix }}'
        $versionSuffix = '${{ steps.git-version.outputs.versionSuffix }}'
        $versionRevision = '${{ steps.git-version.outputs.versionRevision }}'
        $assemblyVersion = '${{ steps.git-version.outputs.assemblyVersion }}'
        $fileVersion = '${{ steps.git-version.outputs.fileVersion }}'
        $productVersion = '${{ steps.git-version.outputs.productVersion }}'
        $informationalVersion = '${{ steps.git-version.outputs.informationalVersion }}'

        Write-Host "##vso[task.setvariable variable=Build.VersionPrefix]$versionPrefix"
        Write-Host "##vso[task.setvariable variable=Build.VersionSuffix]$versionSuffix"
        Write-Host "##vso[task.setvariable variable=Build.AssemblyVersion]$assemblyVersion"
        Write-Host "##vso[task.setvariable variable=Build.FileVersion]$fileVersion"
        Write-Host "##vso[task.setvariable variable=Build.ProductVersion]$productVersion"
        Write-Host "##vso[task.setvariable variable=Build.InformationalVersion]$informationalVersion"
      shell: pwsh

    # Build Solution: creates PFX file from BASe64 secret if signing is enabled
    - name: 'Build Solution: prepare signing'
      if:  ${{ inputs.store-artifacts && inputs.sign-binaries }}
      run: |
        $encodedBytes = "${{ secrets.SIGNING_CERT_PFX }}"
        [convert]::FromBase64String($encodedBytes) | Set-Content -Path ${{ runner.temp }}\cert.pfx -Encoding Byte
      shell: powershell

    - name: 'Build: Restore CertTools'
      run: dotnet restore ${{ env.CertToolsSolutionPath }}
      shell: pwsh

    - name: 'Build: Build CertTools'
      run: dotnet build ${{ env.CertToolsSolutionPath }} --configuration ${{ inputs.configuration }} --no-restore
      shell: pwsh

    - name: 'Build: Publish CertTools CreateRootCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.CertToolsPath }}\CreateRootCert\CreateRootCert.csproj --configuration ${{ inputs.configuration }} --no-build --no-restore --self-contained -p:PublishProfile=${{ env.CertToolsPath }}\CreateRootCert\Properties\PublishProfiles\FolderProfile.pubxml
      shell: pwsh

    - name: 'Build: Publish CertTools CreateSigningCert'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.CertToolsPath }}\CreateSigningCert\CreateSigningCert.csproj --configuration ${{ inputs.configuration }} --no-build --no-restore
      shell: pwsh

    - name: 'Build: Restore AzureCertTools'
      run: dotnet restore ${{ env.AzureCertToolsSolutionPath }}
      shell: pwsh

    - name: 'Build: Build AzureCertTools'
      run: dotnet build ${{ env.AzureCertToolsSolutionPath }} --configuration ${{ inputs.configuration }} --no-restore
      shell: pwsh

    - name: 'Build: Publish AzureCertTools'
      if: ${{ inputs.store-artifacts }}
      run: |
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureCreateRootCert/AzureCreateRootCert.csproj `
          --configuration ${{ inputs.configuration }} `
          --no-build `
          --no-restore `
          --self-contained `
          --runtime win-x64 `
          /p:PublishProfile=${{ env.AzureCertToolsPath }}/AzureCreateRootCert/Properties/PublishProfiles/FolderProfile.pubxml
        dotnet publish ${{ env.AzureCertToolsPath }}/AzureCreateSigningCert/AzureCreateSigningCert.csproj `
          --configuration ${{ inputs.configuration }} `
          --no-build `
          --no-restore `
          /p:PublishProfile=${{ env.AzureCertToolsPath }}/AzureCreateSigningCert/Properties/PublishProfiles/FolderProfile.pubxml
      shell: pwsh
    
    - name: 'Build: Sign published binaries'
      if: ${{ inputs.store-artifacts && inputs.sign-binaries }}
      uses: ./eng/actions/sign-binaries
      with:
        binaries-path: ${{ env.BinaryOutputPath }}
        signing-cert-file: ${{ runner.temp }}\cert.pfx
        signing-cert-password: ${{ secrets.SIGNING_CERT_PASSWORD }}
        signing-cert-thumbprint: ${{ secrets.SIGNING_CERT_THUMBPRINT }}
        signing-timestamp-server: 'http://timestamp.sectigo.com'

    - name: 'Build: signing cleanup'
      if:  ${{ inputs.store-artifacts && inputs.sign-binaries }}
      run: |
        Remove-Item -Path ${{ runner.temp }}\cert.pfx -ErrorAction Continue
      shell: pwsh

    - name: 'Store Artifacts: Binaries'
      uses: actions/upload-artifact@v4
      if: ${{ inputs.store-artifacts }}
      with:
        name: binaries
        path: ${{ env.BinaryOutputPath }}
